import json
import math
import numpy as np
import random

# Define hyperparameters
NUM_QUERIES = 100 # Number of queries to generate
MAX_HEIGHT = 3 # Maximum height of the query tree.
FRAC_LABELS = 0.5 # Proportion of Leafs that are labels.
FRAC_AND = 0.5 # Proportion of branches that are Ands.
FRAC_VARIANCE = 0.5 # Proportion of each metric mean that we should be allowed to deviate from.
METADATA_FILE = "./metadata/metadata_128k.txt" # File to pull metadata from, generated by ./generate_metadata.py

# Grab metadata
random.seed(1)
ops = ["Eq", "NEq", "Gt", "Lt", "GtEq", "LtEq"]
with open(METADATA_FILE) as file:
    labels = json.loads(file.readline())
    metrics = json.loads(file.readline())

# Function to generate a label pair.
def generate_label_pair():
    labelkey = random.choice(list(labels.keys()))
    labelvalue = random.choice(labels[labelkey])
    return labelkey, labelvalue

# Function to generate a metric pair.
def generate_metric_pair():
    metricvariable = random.choice(list(metrics.keys()))
    metricmean = metrics[metricvariable]
    metricvariance = metricmean * FRAC_VARIANCE
    metricvalue = math.trunc(np.random.normal(loc=metricmean, scale=metricvariance) * 1000) / 1000
    return metricvariable, metricvalue

# Function to generate a condition recursively.
def generate_condition(h):
    if h == 0: # Generate a Leaf
        if random.random() > FRAC_LABELS:
            labelkey, labelvalue = generate_label_pair()
            ret = {
                "Leaf": {
                    "lhs": { "LabelKey": labelkey },
                    "rhs": { "LabelValue": labelvalue },
                    "op": "Eq"
                }
            }
        else:
            metricvariable, metricvalue = generate_metric_pair()
            ret = {
                "Leaf": {
                    "lhs": { "Variable": metricvariable },
                    "rhs": { "Metric": metricvalue },
                    "op": random.choice(ops)
                }
            }
        return ret

    else: # Generate an And or an Or, and recurse
        op = "And" if random.random() > FRAC_AND else "Or"
        ret = {
            op: [ generate_condition(h-1), generate_condition(h-1)]
        }
        return ret
        
        
# Generate NUM_QUERIES queries.
for _ in range(NUM_QUERIES):
    query = {
        "Select": {
            "name": "generated_select",
            "predicate": {
                "name": "generated_predicate",
                "condition": generate_condition(MAX_HEIGHT)
            }
        }
    }
    print(json.dumps(query))


